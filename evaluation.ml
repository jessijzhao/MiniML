(*
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2018
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;

(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;


(*......................................................................
  Environments and values
 *)

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value = Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      try
        !(List.assoc varname env)
      with
        Not_found -> raise (EvalError ("Unbound variable" ^ varname )) ;;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let rec extend (env : env) (varname : varid) (loc : value ref) : env =
      match env with
      | [] -> [(varname, loc)]
      | (n, v) :: tl -> if n = varname then (n, loc) :: tl
                        else (n, v) :: (extend tl varname loc) ;;

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      let etcs = exp_to_concrete_string in
      match v with
      | Val exp -> build "Val" [etcs exp]
      | Closure (exp, env) -> if printenvp then
                                build "Closure" [etcs exp; env_to_string env]
                              else build "Closure" [etcs exp; "env"]

    (* Returns a printable string representation of an environment *)
    and env_to_string (env : env) : string =
      match env with
        | [] -> "[]"
        | (n, v) :: tl -> n ^ " -> " ^ value_to_string !v ^ ", " ^
                          env_to_string tl ;;
  end ;;


(*......................................................................
  Evaluation functions

  Returns a result of type value of evaluating the expression exp
  in the environment env. We've provided an initial implementation
  for a trivial evaluator, which just converts the expression
  unchanged to a value and returns it, along with "stub code" for
  three more evaluators: a substitution model evaluator and dynamic
  and lexical environment model versions.

  Each evaluator is of type expr -> Env.env -> Env.value for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures). *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)

let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp ;;


(* Some COMMON EVALUATION functions for eval_s, eval_d, eval_l *)

let eval_c (exp : expr) : expr =
  match exp with
  | Num _ | Bool _ | Fun _ -> exp
  | Unop (u, e) -> (match u with
                    | Negate -> Binop(Times, Num(-1), e))
  | Raise -> raise EvalException
  | Unassigned -> raise (EvalError "Unassigned")
  | _ -> raise (EvalError "No common evaluation for this expression") ;;

let binop_c (b : binop) (e1 : expr) (e2 : expr) : expr =
  match e1, e2 with
  | Num n,  Num m  -> (match b with
                       | Plus -> Num (n + m)
                       | Minus -> Num (n - m)
                       | Times -> Num (n * m)
                       | Equals -> Bool (n = m)
                       | LessThan -> Bool (n < m))
  | Bool n, Bool m -> (match b with
                       | Equals -> Bool (n = m)
                       | _ -> raise (EvalError "Bools can't do that binop"))
  | _ -> raise (EvalError "Binop called on invalid types") ;;

let cond_c (i : expr) (t : expr) (e : expr) : expr =
  match i with
  | Bool cond -> if cond then t else e
  | _ -> raise (EvalError "Condition must be of type bool") ;;


(* The SUBSTITUTION MODEL evaluator *)

let eval_s (exp : expr) (_env : Env.env) : Env.value =
  let rec eval (exp : expr) : expr =
    match exp with
    | Num _ | Bool _ | Fun _ | Raise | Unassigned -> eval_c exp
    | Var x -> raise (EvalError ("Unbound value " ^ x))
    | Unop _ -> eval (eval_c exp)
    | Binop (b, e1, e2) -> binop_c b (eval e1) (eval e2)
    | Conditional (i, t, e) -> eval (cond_c (eval i) t e)
    | Let (x, def, body) -> eval (subst x (eval def) body)
    | Letrec (x, def, body) -> let e = subst x (Letrec (x, def, Var x)) def in
                               eval (subst x (eval e) body)
    | App (e1, e2) -> (match eval e1 with
                       | Fun (v, e) -> eval (subst v (eval e2) e)
                       | _ -> raise (EvalError "Nonfunction cannot be applied"))
  in Env.Val (eval exp) ;;

(* A blueprint for both the dynamically scoped and lexically scoped
   ENVIRONMENT MODEL EVALUATOR *)

let rec eval (subst : bool) (dynamic : bool) (exp : expr) (env : Env.env) : Env.value =
  let open Env in
  let eval' = eval subst dynamic in
  let get_val (value : Env.value) : expr =
    match value with
    | Val exp -> exp
    | _ -> raise (EvalError "Type Error")
  in
  match exp with
  | Num _ | Bool _ | Raise | Unassigned -> Val (eval_c exp)
  | Var x -> if dynamic then (match lookup env x with
             | Val _ -> lookup env x
             | Closure _ -> raise (EvalError ("Unbound value " ^ x)))
             else lookup env x
  | Unop _ -> eval' (eval_c exp) env
  | Binop (b, e1, e2) -> Val (binop_c b (get_val (eval' e1 env))
                                        (get_val (eval' e2 env)))
  | Conditional (i, t, e) -> eval' (cond_c (get_val (eval' i env)) t e) env
  | Fun _ -> if dynamic then Val (eval_c exp) else close exp env
  | Let (x, def, body) -> eval' body (extend env x (ref (eval' def env)))
  | Letrec (x, def, body) -> let x' = ref (Val Unassigned) in
                             let env' = extend env x x' in
                             x' := eval' def env';
                             eval' body env'
  | App (f, app) -> if dynamic then (match get_val (eval' f env) with
                     | Fun (x, def) ->
                        eval' def (extend env x (ref (eval' app env)))
                     | _ -> raise (EvalError "Nonfunction cannot be applied"))
                     else (match eval' f env with
                     | Closure (Fun (x, def), env') ->
                          eval' def (extend env' x (ref (eval' app env)))
                     | _ -> raise (EvalError "Nonfunction cannot be applied"));;

let eval_s = eval true true ;;
(* The DYNAMICALLY-SCOPED ENVIRONMENT MODEL evaluator  *)
let eval_d = eval false true ;;

(* The LEXICALLY-SCOPED ENVIRONMENT MODEL evaluator *)
let eval_l = eval false false ;;

(* Connecting the evaluators to the external world. The REPL in
   miniml.ml uses a call to the single function evaluate defined
   here. *)

let evaluate = eval_l ;;
